pipeline {
    agent any
    tools {
        nodejs 'nodejs23'
    }
    
    environment {
        DOCKERHUB_CRED = credentials('dockerhub-id')
        IMAGE_TAG = "${env.GIT_COMMIT.take(7)}"
        SLACK_CHANNEL = '#deployments'
        EMAIL_RECIPIENTS = 'team@example.com'
        NPM_CACHE_DIR = "${env.WORKSPACE}/.npm-cache"
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Detect Changes') {
            steps {
                script {
                    sh 'git fetch origin main'
                    
                    def changedFiles = sh(
                    script: "git diff --name-only origin/main",
                    returnStdout: true
                    ).trim().split("\n")
                    
                    echo "Changed files: ${changedFiles}"
                    
                    env.USER_CHANGED = changedFiles.any { it.startsWith("services/user-service/") }.toString()
                    env.PRODUCT_CHANGED = changedFiles.any { it.startsWith("services/product-service/") }.toString()
                    env.PAYMENT_CHANGED = changedFiles.any { it.startsWith("services/payment/") }.toString()
                    env.CART_CHANGED = changedFiles.any { it.startsWith("services/cart/") }.toString()
                    
                    env.CHANGED_SERVICES = []
                    if (env.USER_CHANGED == 'true') env.CHANGED_SERVICES.add('user-service')
                    if (env.PRODUCT_CHANGED == 'true') env.CHANGED_SERVICES.add('product-service')
                    if (env.PAYMENT_CHANGED == 'true') env.CHANGED_SERVICES.add('payment')
                    if (env.CART_CHANGED == 'true') env.CHANGED_SERVICES.add('cart')
                }
            }
        }
        
        stage('Docker Login') {
            steps {
                script {
                    sh "echo ${DOCKERHUB_CRED_PSW} | docker login -u ${DOCKERHUB_CRED_USR} --password-stdin"
                }
            }
        }
        
        stage('Build & Deploy Services') {
            parallel {
                stage('User Service') {
                    when {
                        expression {
                            env.USER_PREVIOUS_VERSION == null || env.USER_PREVIOUS_VERSION == 'none' || env.USER_CHANGED == 'true'
                        }
                    }
                    steps {
                        dir('services/user-service') {
                            script {
                                try {
                                    def serviceCacheDir = "${NPM_CACHE_DIR}/user-service"
                                    sh "mkdir -p ${serviceCacheDir}"
                                    sh "npm install --cache ${serviceCacheDir} --prefer-offline"
                                    sh "node index.js &"
                                    
                                    sh "docker build -t mokchhedul/user-service:${IMAGE_TAG} ."
                                    sh "docker push mokchhedul/user-service:${IMAGE_TAG}"
                                    
                                    def previousVersion = sh(
                                    script: "helm get values user-service -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
                                    returnStdout: true
                                    ).trim()
                                    env.USER_PREVIOUS_VERSION = previousVersion
                                    
                                    sh "helm upgrade --install user-service k8s/user-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
                                    sh "kubectl rollout status deployment/user-service --timeout=120s"
                                }catch (Exception e) {
                                    currentBuild.result = 'FAILURE'
                                    error "User Service deployment failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                }
                
                stage('Product Service') {
                    when {
                        expression {
                            env.PRODUCT_PREVIOUS_VERSION == null || env.PRODUCT_PREVIOUS_VERSION == 'none' || env.PRODUCT_CHANGED == 'true'
                        }
                    }
                    steps {
                        dir('services/product-service') {
                            script {
                                try {
                                    def serviceCacheDir = "${NPM_CACHE_DIR}/product-service"
                                    sh "mkdir -p ${serviceCacheDir}"
                                    sh "npm install --cache ${serviceCacheDir} --prefer-offline"
                                    sh "node index.js &"
                                    
                                    sh "docker build -t mokchhedul/product-service:${IMAGE_TAG} ."
                                    sh "docker push mokchhedul/product-service:${IMAGE_TAG}"
                                    
                                    def previousVersion = sh(
                                    script: "helm get values product-service -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
                                    returnStdout: true
                                    ).trim()
                                    env.PRODUCT_PREVIOUS_VERSION = previousVersion
                                    
                                    sh "helm upgrade --install product-service k8s/product-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
                                    sh "kubectl rollout status deployment/product-service --timeout=120s"
                                }catch (Exception e) {
                                    currentBuild.result = 'FAILURE'
                                    error "Product Service deployment failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                }
                
                stage('Payment Service') {
                    when {
                        expression {
                            env.PAYMENT_PREVIOUS_VERSION == null || env.PAYMENT_PREVIOUS_VERSION == 'none' || env.PAYMENT_CHANGED == 'true'
                        }
                    }
                    steps {
                        dir('services/payment') {
                            script {
                                try {
                                    def serviceCacheDir = "${NPM_CACHE_DIR}/payment"
                                    sh "mkdir -p ${serviceCacheDir}"
                                    sh "npm install --cache ${serviceCacheDir} --prefer-offline"
                                    sh "node index.js &"
                                    
                                    sh "docker build -t mokchhedul/payment:${IMAGE_TAG} ."
                                    sh "docker push mokchhedul/payment:${IMAGE_TAG}"
                                    
                                    def previousVersion = sh(
                                    script: "helm get values payment -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
                                    returnStdout: true
                                    ).trim()
                                    env.PAYMENT_PREVIOUS_VERSION = previousVersion
                                    
                                    sh "helm upgrade --install payment k8s/payment-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
                                    sh "kubectl rollout status deployment/payment --timeout=120s"
                                }catch (Exception e) {
                                    currentBuild.result = 'FAILURE'
                                    error "Payment Service deployment failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                }
                
                stage('Cart Service') {
                    when {
                        expression {
                            env.CART_PREVIOUS_VERSION == null || env.CART_PREVIOUS_VERSION == 'none' || env.CART_CHANGED == 'true'
                        }
                    }
                    steps {
                        dir('services/cart') {
                            script {
                                try {
                                    def serviceCacheDir = "${NPM_CACHE_DIR}/cart"
                                    sh "mkdir -p ${serviceCacheDir}"
                                    sh "npm install --cache ${serviceCacheDir} --prefer-offline"
                                    sh "node index.js &"
                                    
                                    sh "docker build -t mokchhedul/cart:${IMAGE_TAG} ."
                                    sh "docker push mokchhedul/cart:${IMAGE_TAG}"
                                    
                                    def previousVersion = sh(
                                    script: "helm get values cart -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
                                    returnStdout: true
                                    ).trim()
                                    env.CART_PREVIOUS_VERSION = previousVersion
                                    
                                    sh "helm upgrade --install cart k8s/cart-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
                                    sh "kubectl rollout status deployment/cart --timeout=120s"
                                }catch (Exception e) {
                                    currentBuild.result = 'FAILURE'
                                    error "Cart Service deployment failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
        
        post {
            always {
                script {
                    sh "find ${NPM_CACHE_DIR} -type f -name '*.tgz' -mtime +7 -delete || true"
                    // notifications...
                }
            }
        success { echo "Pipeline finished successfully." }
        failure {
            script {
                echo "Pipeline failed. Attempting rollback..."
                // rollback logic
            }
        }
    }
}

