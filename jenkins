pipeline {
    agent any
    tools {
        nodejs 'nodejs23'
    }
    
    environment {
        DOCKERHUB_CRED = credentials('dockerhub-id')
        IMAGE_TAG = "${env.GIT_COMMIT.take(7)}"
        SLACK_CHANNEL = '#deployments'
        EMAIL_RECIPIENTS = 'team@example.com'
        NPM_CACHE_DIR = "${env.WORKSPACE}/.npm-cache"
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Detect Changes') {
            steps {
                script {
                    sh 'git fetch origin main'
                    
                    def changedFiles = sh(
                    script: "git diff --name-only origin/main",
                    returnStdout: true
                    ).trim().split("\n")
                    
                    echo "Changed files: ${changedFiles}"
                    
                    env.USER_CHANGED = changedFiles.any { it.startsWith("services/user-service/") }.toString()
                    env.PRODUCT_CHANGED = changedFiles.any { it.startsWith("services/product-service/") }.toString()
                    env.PAYMENT_CHANGED = changedFiles.any { it.startsWith("services/payment/") }.toString()
                    env.CART_CHANGED = changedFiles.any { it.startsWith("services/cart/") }.toString()
                    
                    env.CHANGED_SERVICES = []
                    if (env.USER_CHANGED == 'true') env.CHANGED_SERVICES.add('user-service')
                    if (env.PRODUCT_CHANGED == 'true') env.CHANGED_SERVICES.add('product-service')
                    if (env.PAYMENT_CHANGED == 'true') env.CHANGED_SERVICES.add('payment')
                    if (env.CART_CHANGED == 'true') env.CHANGED_SERVICES.add('cart')
                }
            }
        }
        
        stage('Docker Login') {
            steps {
                script {
                    sh "echo ${DOCKERHUB_CRED_PSW} | docker login -u ${DOCKERHUB_CRED_USR} --password-stdin"
                }
            }
        }
        
        stage('Build & Deploy Services') {
            parallel {
                stage('User Service') {
                    when {
                        expression {
                            env.USER_PREVIOUS_VERSION == null || env.USER_PREVIOUS_VERSION == 'none' || env.USER_CHANGED == 'true'
                        }
                    }
                    steps {
                        dir('services/user-service') {
                            script {
                                try {
                                    def serviceCacheDir = "${NPM_CACHE_DIR}/user-service"
                                    sh "mkdir -p ${serviceCacheDir}"
                                    sh "npm install --cache ${serviceCacheDir} --prefer-offline"
                                    sh "node index.js &"
                                    
                                    sh "docker build -t mokchhedul/user-service:${IMAGE_TAG} ."
                                    sh "docker push mokchhedul/user-service:${IMAGE_TAG}"
                                    
                                    def previousVersion = sh(
                                    script: "helm get values user-service -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
                                    returnStdout: true
                                    ).trim()
                                    env.USER_PREVIOUS_VERSION = previousVersion
                                    
                                    sh "helm upgrade --install user-service k8s/user-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
                                    sh "kubectl rollout status deployment/user-service --timeout=120s"
                                }catch (Exception e) {
                                    currentBuild.result = 'FAILURE'
                                    error "User Service deployment failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                }
                
                stage('Product Service') {
                    when {
                        expression {
                            env.PRODUCT_PREVIOUS_VERSION == null || env.PRODUCT_PREVIOUS_VERSION == 'none' || env.PRODUCT_CHANGED == 'true'
                        }
                    }
                    steps {
                        dir('services/product-service') {
                            script {
                                try {
                                    def serviceCacheDir = "${NPM_CACHE_DIR}/product-service"
                                    sh "mkdir -p ${serviceCacheDir}"
                                    sh "npm install --cache ${serviceCacheDir} --prefer-offline"
                                    sh "node index.js &"
                                    
                                    sh "docker build -t mokchhedul/product-service:${IMAGE_TAG} ."
                                    sh "docker push mokchhedul/product-service:${IMAGE_TAG}"
                                    
                                    def previousVersion = sh(
                                    script: "helm get values product-service -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
                                    returnStdout: true
                                    ).trim()
                                    env.PRODUCT_PREVIOUS_VERSION = previousVersion
                                    
                                    sh "helm upgrade --install product-service k8s/product-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
                                    sh "kubectl rollout status deployment/product-service --timeout=120s"
                                }catch (Exception e) {
                                    currentBuild.result = 'FAILURE'
                                    error "Product Service deployment failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                }
                
                stage('Payment Service') {
                    when {
                        expression {
                            env.PAYMENT_PREVIOUS_VERSION == null || env.PAYMENT_PREVIOUS_VERSION == 'none' || env.PAYMENT_CHANGED == 'true'
                        }
                    }
                    steps {
                        dir('services/payment') {
                            script {
                                try {
                                    def serviceCacheDir = "${NPM_CACHE_DIR}/payment"
                                    sh "mkdir -p ${serviceCacheDir}"
                                    sh "npm install --cache ${serviceCacheDir} --prefer-offline"
                                    sh "node index.js &"
                                    
                                    sh "docker build -t mokchhedul/payment:${IMAGE_TAG} ."
                                    sh "docker push mokchhedul/payment:${IMAGE_TAG}"
                                    
                                    def previousVersion = sh(
                                    script: "helm get values payment -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
                                    returnStdout: true
                                    ).trim()
                                    env.PAYMENT_PREVIOUS_VERSION = previousVersion
                                    
                                    sh "helm upgrade --install payment k8s/payment-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
                                    sh "kubectl rollout status deployment/payment --timeout=120s"
                                }catch (Exception e) {
                                    currentBuild.result = 'FAILURE'
                                    error "Payment Service deployment failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                }
                
                stage('Cart Service') {
                    when {
                        expression {
                            env.CART_PREVIOUS_VERSION == null || env.CART_PREVIOUS_VERSION == 'none' || env.CART_CHANGED == 'true'
                        }
                    }
                    steps {
                        dir('services/cart') {
                            script {
                                try {
                                    def serviceCacheDir = "${NPM_CACHE_DIR}/cart"
                                    sh "mkdir -p ${serviceCacheDir}"
                                    sh "npm install --cache ${serviceCacheDir} --prefer-offline"
                                    sh "node index.js &"
                                    
                                    sh "docker build -t mokchhedul/cart:${IMAGE_TAG} ."
                                    sh "docker push mokchhedul/cart:${IMAGE_TAG}"
                                    
                                    def previousVersion = sh(
                                    script: "helm get values cart -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
                                    returnStdout: true
                                    ).trim()
                                    env.CART_PREVIOUS_VERSION = previousVersion
                                    
                                    sh "helm upgrade --install cart k8s/cart-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
                                    sh "kubectl rollout status deployment/cart --timeout=120s"
                                }catch (Exception e) {
                                    currentBuild.result = 'FAILURE'
                                    error "Cart Service deployment failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                }
            }
        }
        
        post {
            always {
                script {
                    sh "find ${NPM_CACHE_DIR} -type f -name '*.tgz' -mtime +7 -delete || true"
                    // notifications...
                }
            }
        success { echo "Pipeline finished successfully." }
        failure {
            script {
                echo "Pipeline failed. Attempting rollback..."
                // rollback logic
            }
        }
    }
}

// pipeline {
//     agent any
//     tools {
//         nodejs 'nodejs23'
//     }

//     environment {
//         DOCKERHUB_CRED = credentials('dockerhub-id')
//         IMAGE_TAG = "${env.GIT_COMMIT.take(7)}"
//         SLACK_CHANNEL = '#deployments'
//         EMAIL_RECIPIENTS = 'team@example.com'
//         NPM_CACHE_DIR = "${env.WORKSPACE}/.npm-cache"
//     }

//     stages {
//         stage('Checkout') {
//             steps {
//                 checkout scm
//             }
//         }

//         stage('Detect Changes') {
//             steps {
//                 script {
//                     sh 'git fetch origin main'

//                     def changedFiles = sh(
//                     script: "git diff --name-only origin/main",
//                     returnStdout: true
//                     ).trim().split("\n")

//                     echo "Changed files: ${changedFiles}"

//                     env.USER_CHANGED = changedFiles.any { it.startsWith("services/user-service/") }.toString()
//                     env.PRODUCT_CHANGED = changedFiles.any { it.startsWith("services/product-service/") }.toString()
//                     env.PAYMENT_CHANGED = changedFiles.any { it.startsWith("services/payment/") }.toString()
//                     env.CART_CHANGED = changedFiles.any { it.startsWith("services/cart/") }.toString()

//                     env.CHANGED_SERVICES = []
//                     if (env.USER_CHANGED == 'true') env.CHANGED_SERVICES.add('user-service')
//                     if (env.PRODUCT_CHANGED == 'true') env.CHANGED_SERVICES.add('product-service')
//                     if (env.PAYMENT_CHANGED == 'true') env.CHANGED_SERVICES.add('payment')
//                     if (env.CART_CHANGED == 'true') env.CHANGED_SERVICES.add('cart')
//                 }
//             }
//         }

//         stage('Docker Login') {
//             steps {
//                 script {
//                     sh "echo ${DOCKERHUB_CRED_PSW} | docker login -u ${DOCKERHUB_CRED_USR} --password-stdin"
//                 }
//             }
//         }

//         stage('Build & Deploy') {
//             parallel {
//                 stage('User Service') {
//                     when {
//                         expression {
//                             env.USER_PREVIOUS_VERSION == null || env.USER_PREVIOUS_VERSION == 'none' || env.USER_CHANGED == 'true'
//                         }
//                     }
//                     steps {
//                         dir('services/user-service') {
//                             script {
//                                 try {
//                                     def serviceCacheDir = "${NPM_CACHE_DIR}/user-service"
//                                     sh "mkdir -p ${serviceCacheDir}"
//                                     sh "npm install --cache ${serviceCacheDir} --prefer-offline"
//                                     sh "npm start "
//                                     sh "docker build -t username/user-service:${IMAGE_TAG} ."
//                                     sh "docker push username/user-service:${IMAGE_TAG}"

//                                     def previousVersion = sh(
//                                     script: "helm get values user-service -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
//                                     returnStdout: true
//                                     ).trim()
//                                     env.USER_PREVIOUS_VERSION = previousVersion

//                                     sh "helm upgrade --install user-service k8s/user-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
//                                     sh "kubectl rollout status deployment/user-service --timeout=120s"
//                                 }catch (Exception e) {
//                                     currentBuild.result = 'FAILURE'
//                                     error "User Service deployment failed: ${e.getMessage()}"
//                                 }
//                             }
//                         }
//                     }
//                 }

// stage('Product Service') {
//     when {
//         expression {
//             env.PRODUCT_PREVIOUS_VERSION == null || env.PRODUCT_PREVIOUS_VERSION == 'none' || env.PRODUCT_CHANGED == 'true'
//         }
//     }
//     steps {
//         dir('services/product-service') {
//             script {
//                 try {
//                     def serviceCacheDir = "${NPM_CACHE_DIR}/product-service"
//                     sh "mkdir -p ${serviceCacheDir}"
//                     sh "npm install --cache ${serviceCacheDir} --prefer-offline"
//                     sh "npm start"
//                     sh "docker build -t username/product-service:${IMAGE_TAG} ."
//                     sh "docker push username/product-service:${IMAGE_TAG}"

//                     def previousVersion = sh(
//                     script: "helm get values product-service -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
//                     returnStdout: true
//                     ).trim()
//                     env.PRODUCT_PREVIOUS_VERSION = previousVersion

//                     sh "helm upgrade --install product-service k8s/product-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
//                     sh "kubectl rollout status deployment/product-service --timeout=120s"
//                 }catch (Exception e) {
//                     currentBuild.result = 'FAILURE'
//                     error "Product Service deployment failed: ${e.getMessage()}"
//                 }
//             }
//         }
//     }
// }

// stage('Payment Service') {
//     when {
//         expression {
//             env.PAYMENT_PREVIOUS_VERSION == null || env.PAYMENT_PREVIOUS_VERSION == 'none' || env.PAYMENT_CHANGED == 'true'
//         }
//     }
//     steps {
//         dir('services/payment') {
//             script {
//                 try {
//                     def serviceCacheDir = "${NPM_CACHE_DIR}/payment"
//                     sh "mkdir -p ${serviceCacheDir}"
//                     sh "npm install --cache ${serviceCacheDir} --prefer-offline"
//                     sh "npm start"
//                     sh "docker build -t username/payment:${IMAGE_TAG} ."
//                     sh "docker push username/payment:${IMAGE_TAG}"

//                     def previousVersion = sh(
//                     script: "helm get values payment -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
//                     returnStdout: true
//                     ).trim()
//                     env.PAYMENT_PREVIOUS_VERSION = previousVersion

//                     sh "helm upgrade --install payment k8s/payment-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
//                     sh "kubectl rollout status deployment/payment --timeout=120s"
//                 }catch (Exception e) {
//                     currentBuild.result = 'FAILURE'
//                     error "Payment Service deployment failed: ${e.getMessage()}"
//                 }
//             }
//         }
//     }
// }

// stage('Cart Service') {
//     when {
//         expression {
//             env.CART_PREVIOUS_VERSION == null || env.CART_PREVIOUS_VERSION == 'none' || env.CART_CHANGED == 'true'
//         }
//     }
//     steps {
//         dir('services/cart') {
//             script {
//                 try {
//                     def serviceCacheDir = "${NPM_CACHE_DIR}/cart"
//                     sh "mkdir -p ${serviceCacheDir}"
//                     sh "npm install --cache ${serviceCacheDir} --prefer-offline"
//                     sh "npm start"
//                     sh "docker build -t username/cart:${IMAGE_TAG} ."
//                     sh "docker push username/cart:${IMAGE_TAG}"

//                     def previousVersion = sh(
//                     script: "helm get values cart -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
//                     returnStdout: true
//                     ).trim()
//                     env.CART_PREVIOUS_VERSION = previousVersion

//                     sh "helm upgrade --install cart k8s/cart-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
//                     sh "kubectl rollout status deployment/cart --timeout=120s"
//                 }catch (Exception e) {
//                     currentBuild.result = 'FAILURE'
//                     error "Cart Service deployment failed: ${e.getMessage()}"
//                 }
//             }
//         }
//     }
//             // }
//         }
//     }
//     } // stages block ends

//     post {
//         always {
//             script {
//                 sh "find ${NPM_CACHE_DIR} -type f -name '*.tgz' -mtime +7 -delete || true"
//                 if (currentBuild.result == 'FAILURE') {
//                     sendFailureNotification()
//                 }else if (currentBuild.result == 'SUCCESS') {
//                     sendSuccessNotification()
//                 }else {
//                     sendGenericNotification()
//                 }
//             }
//         }
//         success {
//             echo "Pipeline finished successfully."
//         }
//         failure {
//             script {
//                 echo "Pipeline failed. Attempting rollback..."
//                 rollbackDeployments()
//                 echo "Rollback completed. Check logs for details!"
//             }
//         }
//         unstable {
//             echo "Pipeline finished with unstable state."
//         }
//     }
// }

//         stage('Apply Ingress') {
//             steps {
//                 script {
//                     sh "kubectl apply -f k8s/ingress.yaml"
//                 }
//             }
//         }
//     }

//     post {
//         always {
//             script {
//                 sh "find ${NPM_CACHE_DIR} -type f -name '*.tgz' -mtime +7 -delete || true"
//                 if (currentBuild.result == 'FAILURE') {
//                     sendFailureNotification()
//                 } else if (currentBuild.result == 'SUCCESS') {
//                     sendSuccessNotification()
//                 } else {
//                     sendGenericNotification()
//                 }
//             }
//         }
//         success {
//             echo "Pipeline finished successfully."
//         }
//         failure {
//             script {
//                 echo "Pipeline failed. Attempting rollback..."
//                 rollbackDeployments()
//                 echo "Rollback completed. Check logs for details!"
//             }
//         }
//         unstable {
//             echo "Pipeline finished with unstable state."
//         }
//     }
// }

// // Notification methods (same as before)
// def sendSuccessNotification() {
//     def message = " Pipeline SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER}\n" +
//                  "Changes: ${env.CHANGED_SERVICES.join(', ')}\n" +
//                  "View details: ${env.BUILD_URL}"
//     slackSend channel: "${SLACK_CHANNEL}", message: message, color: 'good'
//     emailext subject: "SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER}", body: message, to: "${EMAIL_RECIPIENTS}"
// }

// def sendFailureNotification() {
//     def message = " Pipeline FAILED: ${env.JOB_NAME} #${env.BUILD_NUMBER}\n" +
//                  "Changes: ${env.CHANGED_SERVICES.join(', ')}\n" +
//                  "View details: ${env.BUILD_URL}\n" +
//                  "Rollback attempted for failed services."
//     slackSend channel: "${SLACK_CHANNEL}", message: message, color: 'danger'
//     emailext subject: "FAILURE: ${env.JOB_NAME} #${env.BUILD_NUMBER}", body: message, to: "${EMAIL_RECIPIENTS}"
// }

// def sendGenericNotification() {
//     def message = " Pipeline finished: ${env.JOB_NAME} #${env.BUILD_NUMBER}\n" +
//                  "Result: ${currentBuild.result}\n" +
//                  "View details: ${env.BUILD_URL}"
//     slackSend channel: "${SLACK_CHANNEL}", message: message, color: '#439FE0'
// }

// // Rollback method (same as before)
// def rollbackDeployments() {
//     script {
//         echo "Starting rollback process for failed deployments..."

//         if (env.USER_CHANGED == 'true' && env.USER_PREVIOUS_VERSION != null && env.USER_PREVIOUS_VERSION != 'none') {
//             try {
//                 echo "Rolling back user-service to version: ${env.USER_PREVIOUS_VERSION}"
//                 sh "helm upgrade --install user-service k8s/user-helm --set image.tag=${env.USER_PREVIOUS_VERSION} --wait --timeout 300s"
//                 sh "kubectl rollout status deployment/user-service --timeout=120s"
//             } catch (Exception e) {
//                 echo "Failed to rollback user-service: ${e.getMessage()}"
//             }
//         }

//         if (env.PRODUCT_CHANGED == 'true' && env.PRODUCT_PREVIOUS_VERSION != null && env.PRODUCT_PREVIOUS_VERSION != 'none') {
//             try {
//                 echo "Rolling back product-service to version: ${env.PRODUCT_PREVIOUS_VERSION}"
//                 sh "helm upgrade --install product-service k8s/product-helm --set image.tag=${env.PRODUCT_PREVIOUS_VERSION} --wait --timeout 300s"
//                 sh "kubectl rollout status deployment/product-service --timeout=120s"
//             } catch (Exception e) {
//                 echo "Failed to rollback product-service: ${e.getMessage()}"
//             }
//         }

//         if (env.PAYMENT_CHANGED == 'true' && env.PAYMENT_PREVIOUS_VERSION != null && env.PAYMENT_PREVIOUS_VERSION != 'none') {
//             try {
//                 echo "Rolling back payment to version: ${env.PAYMENT_PREVIOUS_VERSION}"
//                 sh "helm upgrade --install payment k8s/payment-helm --set image.tag=${env.PAYMENT_PREVIOUS_VERSION} --wait --timeout 300s"
//                 sh "kubectl rollout status deployment/payment --timeout=120s"
//             } catch (Exception e) {
//                 echo "Failed to rollback payment: ${e.getMessage()}"
//             }
//         }

//         if (env.CART_CHANGED == 'true' && env.CART_PREVIOUS_VERSION != null && env.CART_PREVIOUS_VERSION != 'none') {
//             try {
//                 echo "Rolling back cart to version: ${env.CART_PREVIOUS_VERSION}"
//                 sh "helm upgrade --install cart k8s/cart-helm --set image.tag=${env.CART_PREVIOUS_VERSION} --wait --timeout 300s"
//                 sh "kubectl rollout status deployment/cart --timeout=120s"
//             } catch (Exception e) {
//                 echo "Failed to rollback cart: ${e.getMessage()}"
//             }
//         }

//         echo "Rollback process completed."
//     }
// }
