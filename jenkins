pipeline {
    agent any
    
    environment {
        DOCKERHUB_CRED = credentials('dockerhub-id')
        IMAGE_TAG = "${env.GIT_COMMIT.take(7)}"
        SLACK_CHANNEL = '#deployments'
        EMAIL_RECIPIENTS = 'team@example.com'
        NPM_CACHE_DIR = "${env.WORKSPACE}/.npm-cache"
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Detect Changes') {
            steps {
                script {
                    sh 'git fetch origin main'
                    
                    def changedFiles = sh(
                    script: "git diff --name-only origin/main",
                    returnStdout: true
                    ).trim().split("\n")
                    
                    echo "Changed files: ${changedFiles}"
                    
                    env.USER_CHANGED = changedFiles.any { it.startsWith("services/user-service/") }.toString()
                    env.PRODUCT_CHANGED = changedFiles.any { it.startsWith("services/product-service/") }.toString()
                    env.PAYMENT_CHANGED = changedFiles.any { it.startsWith("services/payment-service/") }.toString()
                    env.CART_CHANGED = changedFiles.any { it.startsWith("services/cart-service/") }.toString()
                    
                    env.CHANGED_SERVICES = []
                    if (env.USER_CHANGED == 'true') env.CHANGED_SERVICES.add('user-service')
                    if (env.PRODUCT_CHANGED == 'true') env.CHANGED_SERVICES.add('product-service')
                    if (env.PAYMENT_CHANGED == 'true') env.CHANGED_SERVICES.add('payment-service')
                    if (env.CART_CHANGED == 'true') env.CHANGED_SERVICES.add('cart-service')
                }
            }
        }
        
        stage('Docker Login') {
            steps {
                script {
                    sh "echo ${DOCKERHUB_CRED_PSW} | docker login -u ${DOCKERHUB_CRED_USR} --password-stdin"
                }
            }
        }
        
        stage('Build & Deploy') {
            parallel {
                stage('User Service') {
                    when {
                        expression {
                            env.USER_PREVIOUS_VERSION == null || env.USER_PREVIOUS_VERSION == 'none' || env.USER_CHANGED == 'true'
                        }
                    }
                    steps {
                        dir('services/user-service') {
                            script {
                                try {
                                    def serviceCacheDir = "${NPM_CACHE_DIR}/user-service"
                                    sh "mkdir -p ${serviceCacheDir}"
                                    sh "npm ci --cache ${serviceCacheDir} --prefer-offline"
                                    sh "npm test"
                                    sh "docker build -t username/user-service:${IMAGE_TAG} ."
                                    sh "docker push username/user-service:${IMAGE_TAG}"
                                    
                                    def previousVersion = sh(
                                    script: "helm get values user-service -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
                                    returnStdout: true
                                    ).trim()
                                    env.USER_PREVIOUS_VERSION = previousVersion
                                    
                                    sh "helm upgrade --install user-service k8s/user-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
                                    sh "kubectl rollout status deployment/user-service --timeout=120s"
                                }catch (Exception e) {
                                    currentBuild.result = 'FAILURE'
                                    error "User Service deployment failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                }
                
                stage('Product Service') {
                    when {
                        expression {
                            env.PRODUCT_PREVIOUS_VERSION == null || env.PRODUCT_PREVIOUS_VERSION == 'none' || env.PRODUCT_CHANGED == 'true'
                        }
                    }
                    steps {
                        dir('services/product-service') {
                            script {
                                try {
                                    def serviceCacheDir = "${NPM_CACHE_DIR}/product-service"
                                    sh "mkdir -p ${serviceCacheDir}"
                                    sh "npm ci --cache ${serviceCacheDir} --prefer-offline"
                                    sh "npm test"
                                    sh "docker build -t username/product-service:${IMAGE_TAG} ."
                                    sh "docker push username/product-service:${IMAGE_TAG}"
                                    
                                    def previousVersion = sh(
                                    script: "helm get values product-service -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
                                    returnStdout: true
                                    ).trim()
                                    env.PRODUCT_PREVIOUS_VERSION = previousVersion
                                    
                                    sh "helm upgrade --install product-service k8s/product-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
                                    sh "kubectl rollout status deployment/product-service --timeout=120s"
                                }catch (Exception e) {
                                    currentBuild.result = 'FAILURE'
                                    error "Product Service deployment failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                }
                
                stage('Payment Service') {
                    when {
                        expression {
                            env.PAYMENT_PREVIOUS_VERSION == null || env.PAYMENT_PREVIOUS_VERSION == 'none' || env.PAYMENT_CHANGED == 'true'
                        }
                    }
                    steps {
                        dir('services/payment-service') {
                            script {
                                try {
                                    def serviceCacheDir = "${NPM_CACHE_DIR}/payment-service"
                                    sh "mkdir -p ${serviceCacheDir}"
                                    sh "npm ci --cache ${serviceCacheDir} --prefer-offline"
                                    sh "npm test"
                                    sh "docker build -t username/payment-service:${IMAGE_TAG} ."
                                    sh "docker push username/payment-service:${IMAGE_TAG}"
                                    
                                    def previousVersion = sh(
                                    script: "helm get values payment-service -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
                                    returnStdout: true
                                    ).trim()
                                    env.PAYMENT_PREVIOUS_VERSION = previousVersion
                                    
                                    sh "helm upgrade --install payment-service k8s/payment-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
                                    sh "kubectl rollout status deployment/payment-service --timeout=120s"
                                }catch (Exception e) {
                                    currentBuild.result = 'FAILURE'
                                    error "Payment Service deployment failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                }
                
                stage('Cart Service') {
                    when {
                        expression {
                            env.CART_PREVIOUS_VERSION == null || env.CART_PREVIOUS_VERSION == 'none' || env.CART_CHANGED == 'true'
                        }
                    }
                    steps {
                        dir('services/cart-service') {
                            script {
                                try {
                                    def serviceCacheDir = "${NPM_CACHE_DIR}/cart-service"
                                    sh "mkdir -p ${serviceCacheDir}"
                                    sh "npm ci --cache ${serviceCacheDir} --prefer-offline"
                                    sh "npm test"
                                    sh "docker build -t username/cart-service:${IMAGE_TAG} ."
                                    sh "docker push username/cart-service:${IMAGE_TAG}"
                                    
                                    def previousVersion = sh(
                                    script: "helm get values cart-service -o json | jq -r '.image.tag' 2>/dev/null || echo 'none'",
                                    returnStdout: true
                                    ).trim()
                                    env.CART_PREVIOUS_VERSION = previousVersion
                                    
                                    sh "helm upgrade --install cart-service k8s/cart-helm --set image.tag=${IMAGE_TAG} --wait --timeout 300s"
                                    sh "kubectl rollout status deployment/cart-service --timeout=120s"
                                }catch (Exception e) {
                                    currentBuild.result = 'FAILURE'
                                    error "Cart Service deployment failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                }
            }
        }
        } // stages block ends
        
        post {
            always {
                script {
                    sh "find ${NPM_CACHE_DIR} -type f -name '*.tgz' -mtime +7 -delete || true"
                    if (currentBuild.result == 'FAILURE') {
                        sendFailureNotification()
                    }else if (currentBuild.result == 'SUCCESS') {
                        sendSuccessNotification()
                    }else {
                        sendGenericNotification()
                    }
                }
            }
            success {
                echo "Pipeline finished successfully."
            }
            failure {
                script {
                    echo "Pipeline failed. Attempting rollback..."
                    rollbackDeployments()
                    echo "Rollback completed. Check logs for details!"
                }
            }
            unstable {
                echo "Pipeline finished with unstable state."
            }
        }
    }
    
    //         stage('Apply Ingress') {
    //             steps {
    //                 script {
    //                     sh "kubectl apply -f k8s/ingress.yaml"
    //                 }
    //             }
    //         }
    //     }
    
    //     post {
    //         always {
    //             script {
    //                 sh "find ${NPM_CACHE_DIR} -type f -name '*.tgz' -mtime +7 -delete || true"
    //                 if (currentBuild.result == 'FAILURE') {
    //                     sendFailureNotification()
    //                 } else if (currentBuild.result == 'SUCCESS') {
    //                     sendSuccessNotification()
    //                 } else {
    //                     sendGenericNotification()
    //                 }
    //             }
    //         }
    //         success {
    //             echo "Pipeline finished successfully."
    //         }
    //         failure {
    //             script {
    //                 echo "Pipeline failed. Attempting rollback..."
    //                 rollbackDeployments()
    //                 echo "Rollback completed. Check logs for details!"
    //             }
    //         }
    //         unstable {
    //             echo "Pipeline finished with unstable state."
    //         }
    //     }
    // }
    
    // // Notification methods (same as before)
    // def sendSuccessNotification() {
    //     def message = " Pipeline SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER}\n" +
    //                  "Changes: ${env.CHANGED_SERVICES.join(', ')}\n" +
    //                  "View details: ${env.BUILD_URL}"
    //     slackSend channel: "${SLACK_CHANNEL}", message: message, color: 'good'
    //     emailext subject: "SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER}", body: message, to: "${EMAIL_RECIPIENTS}"
    // }
    
    // def sendFailureNotification() {
    //     def message = " Pipeline FAILED: ${env.JOB_NAME} #${env.BUILD_NUMBER}\n" +
    //                  "Changes: ${env.CHANGED_SERVICES.join(', ')}\n" +
    //                  "View details: ${env.BUILD_URL}\n" +
    //                  "Rollback attempted for failed services."
    //     slackSend channel: "${SLACK_CHANNEL}", message: message, color: 'danger'
    //     emailext subject: "FAILURE: ${env.JOB_NAME} #${env.BUILD_NUMBER}", body: message, to: "${EMAIL_RECIPIENTS}"
    // }
    
    // def sendGenericNotification() {
    //     def message = " Pipeline finished: ${env.JOB_NAME} #${env.BUILD_NUMBER}\n" +
    //                  "Result: ${currentBuild.result}\n" +
    //                  "View details: ${env.BUILD_URL}"
    //     slackSend channel: "${SLACK_CHANNEL}", message: message, color: '#439FE0'
    // }
    
    // // Rollback method (same as before)
    // def rollbackDeployments() {
    //     script {
    //         echo "Starting rollback process for failed deployments..."
    
    //         if (env.USER_CHANGED == 'true' && env.USER_PREVIOUS_VERSION != null && env.USER_PREVIOUS_VERSION != 'none') {
    //             try {
    //                 echo "Rolling back user-service to version: ${env.USER_PREVIOUS_VERSION}"
    //                 sh "helm upgrade --install user-service k8s/user-helm --set image.tag=${env.USER_PREVIOUS_VERSION} --wait --timeout 300s"
    //                 sh "kubectl rollout status deployment/user-service --timeout=120s"
    //             } catch (Exception e) {
    //                 echo "Failed to rollback user-service: ${e.getMessage()}"
    //             }
    //         }
    
    //         if (env.PRODUCT_CHANGED == 'true' && env.PRODUCT_PREVIOUS_VERSION != null && env.PRODUCT_PREVIOUS_VERSION != 'none') {
    //             try {
    //                 echo "Rolling back product-service to version: ${env.PRODUCT_PREVIOUS_VERSION}"
    //                 sh "helm upgrade --install product-service k8s/product-helm --set image.tag=${env.PRODUCT_PREVIOUS_VERSION} --wait --timeout 300s"
    //                 sh "kubectl rollout status deployment/product-service --timeout=120s"
    //             } catch (Exception e) {
    //                 echo "Failed to rollback product-service: ${e.getMessage()}"
    //             }
    //         }
    
    //         if (env.PAYMENT_CHANGED == 'true' && env.PAYMENT_PREVIOUS_VERSION != null && env.PAYMENT_PREVIOUS_VERSION != 'none') {
    //             try {
    //                 echo "Rolling back payment-service to version: ${env.PAYMENT_PREVIOUS_VERSION}"
    //                 sh "helm upgrade --install payment-service k8s/payment-helm --set image.tag=${env.PAYMENT_PREVIOUS_VERSION} --wait --timeout 300s"
    //                 sh "kubectl rollout status deployment/payment-service --timeout=120s"
    //             } catch (Exception e) {
    //                 echo "Failed to rollback payment-service: ${e.getMessage()}"
    //             }
    //         }
    
    //         if (env.CART_CHANGED == 'true' && env.CART_PREVIOUS_VERSION != null && env.CART_PREVIOUS_VERSION != 'none') {
    //             try {
    //                 echo "Rolling back cart-service to version: ${env.CART_PREVIOUS_VERSION}"
    //                 sh "helm upgrade --install cart-service k8s/cart-helm --set image.tag=${env.CART_PREVIOUS_VERSION} --wait --timeout 300s"
    //                 sh "kubectl rollout status deployment/cart-service --timeout=120s"
    //             } catch (Exception e) {
    //                 echo "Failed to rollback cart-service: ${e.getMessage()}"
    //             }
    //         }
    
    //         echo "Rollback process completed."
    //     }
    // }
    